一、学前必知

1 时间复杂度

​	完成操作的基本操作计数

2.空间复杂度

​	运行过程中临时占用存储空间大小的量度

3.对数器

​	准备易写不出错的流程 X（复杂度高） + 随机数发生器（生成随机样本）

​	去测试自己写的复杂度低的算法。

4.OJ常见状态术语

​	AC : Accepted 答案正确

​	WA : Wrong Answer 答案错误

​	TLE : Time Limit Exceeded 运行超时

​	CE : Compile Error 编译错误

​	RE : Runtime Error 运行时出错

​	MLE ： Memory Limit Exceeded 内存超限

​	PE ： Presentation Error  格式错误

二、内容

1 排序算法（通过它热身并了解基础数据结构）

​	1.1冒泡排序

​	1.2快速排序

​	1.3简单插入排序

​	1.4希尔排序

​	1.5简单选择排序

​	1.6堆排序

​	1.7二路归并排序

​	1.8多路归并排序

​	1.9计数排序

​	1.10桶排序

​	1.11基数排序

2 基础数据结构

​	2.1数组

​		基本操作：

​			insert：给定索引位置插入一个元素

​			get：返回索引位置元素

​			delete：删除索引位置元素

​			size：获取数组元素总数

​		常见问题：

​			找到数组第二小的元素

​			找到数组中第一个没有重复整数

​			合并两个分类数组

​			重新排列数组中的正值和负值

​	2.2堆栈

​		基本操作：

​			push：在顶部插入元素

​			pop：在堆栈中删除后返回顶部元素（C++中返回是void）

​			empty：是否为空

​			top：返回顶部元素，但不删除

​		常见问题：

​			使用堆栈计算后缀表达式

​			对堆栈中的值进行排序

​			检查表达式中括号是否平衡

​	2.3队列

​		基本操作：

​			push：队尾增加元素

​			pop：移除队首元素

​			empty：是否为空

​			front/back：返回队首/队尾元素

​		常见问题：

​			使用队列来实现堆栈

​			颠倒队列中前k个元素顺序

​			使用队列生成1-n的二进制数

​	2.4链表

​		基本操作：

​			insert：在队列尾部或头部插入指定元素

​			delete：从链表中删除指定元素

​			search：返回链表中指定元素

​			empty：是否为空

​		常见问题：

​			翻转列表

​			检测链表中循环

​			返回链表中倒数n个节点

​			移除链表中重复值

​	2.5树

​		树的类型：

​			N叉树

​			平衡树

​			二叉树

​			二叉搜索树

​			红黑树

​			2-3树

​		常见问题：

​			找到一个二叉树高度

​			找到一个二叉搜索树中第k个最大值

​			找到距离根部“k”个距离的节点

​			找到一个二叉树给定节点的祖先

​	2.6图

​		图的类型：

​			有向图

​			无向图

​		表现形式：

​			邻接矩阵

​			邻接列表

​		常见图遍历算法：

​			广度优先遍历

​			深度优先遍历

​		常见问题：

​			实现广度、深度优先遍历

​			检查一个图是否为树

​			计算一张图中边的数量

​			找到两个顶点之间的最短路径

​	2.7字典树

​		常见问题：

​			计算字典树中的总字数

​			打印存储字典树中所有单词

​			使用字典树对数组元素进行排序

​			使用字典树从字典中形成单词

​			构建一个T9字典

​	2.8哈希表（键值对）

​		哈希表性能三因素

​			哈希函数

​			哈希表的大小

​			碰撞处理处理方法

​		常见问题：

​			找到数组对称对

​			追踪遍历完整路径

​			查看一个数组是否为另一个数组子集

​			检查给定数组是否不相交

3 基础算法（重要程度递减）

​		3.1拓扑排序算法

​		3.2二分法

​		3.3哈希表

​		3.4二叉查找树

​		3.5动态规划

​		3.6分治法

​		3.7堆

​		3.8贪心法

​		3.9最小生成树算法

​		3.10字典树

​		3.11并查集

​		3.12最短路算法

​		3.13Morris算法

​		3.14ManACher算法

​		3.15KMP算法

​		3.16网络流算法

​		3.17希尔排序（已复习，见排序算法文件夹）

​		3.18线段树

​		3.19平衡排序二叉树

​		3.20跳跃表

​		3.21KD树

​		3.22B树